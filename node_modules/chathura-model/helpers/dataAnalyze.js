/**
 * 
 * @param {Array} array : this array shoud be this format [[input_1 , input_2, input_3 , ouput],[input_1 , input_2, input_3 , ouput],[input_1 , input_2, input_3 , ouput]] 
 *  
 * 
 * @returns analyze of array 
 */

export default function dataAnalyzer(array , isShuffle = false ){
    const classes = [];
    array.forEach(valuesArray => classes.includes(valuesArray[valuesArray.length - 1])?undefined:classes.push(valuesArray[valuesArray.length - 1]));
    classes.sort((a,b)=>a-b);

    const filteredData = [];
    classes.forEach(value=>{
        const data  = array.filter(valuesArray=>{
            if(valuesArray[valuesArray.length - 1] == value){
                return valuesArray;
            }
        })
        filteredData.push(data)
    });

    const filterObject={
        data :{},
        size:{},
        percentages:{},
        balanceData:[],
        minLength:array.length,
    };

   


    classes.forEach((value,index)=>{
        filterObject.data[`${value}`] = filteredData[index];
        const size =filteredData[index].length;
        filterObject.size[`${value}`] = size;
        if(filterObject.minLength > size ) filterObject.minLength = size;
        filterObject.percentages[`${value}`] = ` ${(size / array.length * 100).toFixed(2)}%`
    });

    filterObject.balanceData = filteredData.map(dataArr => dataArr.slice(0,filterObject.minLength));
    filterObject.balanceData = filterObject.balanceData.flat();

    if(isShuffle){
        const arr = new Array(Math.round(filterObject.balanceData.length / (classes.length - 2 ))).fill(0);
        const suffleData = [];
        arr.forEach(_=>{
            suffleData.push([])
        })

        filterObject.balanceData.forEach((valueArray,index)=>{
            const sentIndex = index % suffleData.length;
            suffleData[sentIndex].push(valueArray);
        })

        filterObject.balanceData = suffleData.flat();
    }

    return filterObject;
}