import ModelError from "./helpers/errorHandler.js";
import ModelTools from "./modelToos.js";
import Matrix from "../npm-matrix/matrix.js";
import matrix from "../npm-matrix/matrix.js";


export default class Model extends ModelTools{   
    mode = 'train';
    validationLoss = undefined;
    constructor(layers = []){
        super();
        this.layers = layers;
        this.statements = [];
    }

    config({loss , optimizers , metrixs=[]}){
        this.loss = loss;
        this.optimizer = optimizers ;
        this.metrixs = [...metrixs];

        ////show error with methods
        if(!this.layers) return new ModelError("please create a model before train");

        ////show errors with params
        if(!this.loss) return new ModelError('please provide a loss function');
        if(!this.optimizer) return new ModelError('please provide a optimizer');

        this.layers.forEach((layer,index)=>layer.id = index);


    }

    train({ x, y , epochs = 1 , batches = 1 , validationDataXY , validationSteps ,verbose} = {}){
        this.x = x;
        this.y = y;
        this.epochs = epochs;
        this.batches = batches;
        this.validationDataXY = validationDataXY;
        this.validationData_x = validationDataXY && validationDataXY[0];
        this.validationData_y = validationDataXY && validationDataXY[1];
        this.validationSteps = validationSteps || this.validationData_y?.length;
        this.verbose = verbose

        ////show error with methods
        if(!this.layers) return new ModelError("please create a model before train")
        if(!this.loss && !this.optimizer) return new ModelError("please config a model before train")


        //// show error with params
        if(!x) return new ModelError("x is not provided");
        if(!y) return new ModelError("y is not provided");

        // start training model
        this.#trainModel();
    }

    #trainModel(){
        for(let epoch = 0 ; epoch < this.epochs ; epoch++){

            this.layers.forEach(layer=> layer.mode = 'train');
            
            this.x.forEach((value , index) => {
                this.curr_index = index;
        
                //forword oparations
                this.#forword(value)
                this.#clacLoss()
                this.#metrixForword();

                
                //backword propagation
                this.#clacDloss()
                this.#backword()

                this.#optimize()
    

            })


            if(this.verbose){
                this.#metrixBackword()

                if(this.validationDataXY){
                    if(!this.validationData_x && !this.validationData_y) throw new Error("please provide validation XY conrrectly");
                    if(this.validationData_x?.length != this.validationData_y?.length) throw new Error('validation x and y length are not same');
                    if(this.validationData_x && this.validationData_y ) this.#validateModel();
                }

                
                this.#showLogs(epoch);
            }



            
            
        }

        if(!this.verbose){
            console.log(`Trained for Epochs "${this.epochs.toLocaleString('en-US')}"`)
        }
    }


    #validateModel(){
        this.layers.forEach(layer=> layer.mode = 'validate');
        this.validationData_x?.forEach((value , index) => {
            this.curr_index = index;
    
            //forword oparations
            this.#forword(value)
            this.#metrixForword('validate');
        })

        if(this.verbose){
            this.#metrixBackword(true)
        }
    }

    
    addLayer(layer){
        this.layers.push(layer);
        return
    }





    #forword(value){
        this.currInput =[value]
        this.layers.forEach(layer => {
            layer.forword(this.currInput)
            this.currInput = layer.output
        });

        this.y_preds = this.layers[this.layers.length - 1].output

    }

    #clacLoss(){
        this.curr_loss = this.loss.forword(this.y_preds , this.y[this.curr_index])
    }

    #clacDloss(){
        this.loss.backword()
        this.curr_dvalue = this.loss.dloss;
        if(this.validationLoss)this.loss.validationLoss = this.validationLoss;
    }

    #backword(){
        this.layers.reverse();
        this.layers.forEach(layer=>{
            layer.backword(this.curr_dvalue);
            this.curr_dvalue = layer.dinputs;
        })
        this.layers.reverse();
    }

    #optimize(){
        this.optimizer.preUpdate();
        this.layers.forEach(layer=>{
            this.optimizer.updateParams(layer)
        })
        this.optimizer.postUpdate();
    }

    #metrixForword(mode='train'){
        if (this.metrixs.length == 0 ) return;
        if(mode == 'train') this.metrixs.forEach(metrix => metrix.forword(this.y_preds , this.y[this.curr_index]))
        if(mode == 'validate') this.metrixs.forEach(metrix => metrix.forword(this.y_preds , this.validationData_y[this.curr_index]))
    }

    #metrixBackword(isValidate=false){
        if (this.metrixs.length == 0 ) return;
        this.metrixs.forEach(metrix => {
            this.statements.push(metrix.backword(isValidate));
            this.validationLoss = metrix.validationLoss;
        })


    }

    #showLogs(epoch){
        this.statements.unshift(`Epoch : ${epoch.toLocaleString('en-US')} `);
        const statements = this.statements.join(' || ');
        this.statements = [];
        console.log(statements);
    }

    predict(data){
        this.#forword(data)
        const predictions = this.y_preds
        return predictions
    }

    #createDownloadButton(root,NumberOfLayers,layerShapes,summeryOfmodel){
        if(!root) root = document.querySelector('body');
        if(!root) console.log("please give root for render download statement!");
        const summery_string = `[${[NumberOfLayers]},${layerShapes} ,${summeryOfmodel}]`;


        const download_link = document.createElement('a');
        
        const buttonStyles = {
            backgroundColor : 'crimson',
            padding: '1rem 2rem',
            fontSize: "1rem",
            color:'white',
            fontFamily:'sans-serif',
            textDecoration:'none',
            textTransform:'capitalize',
            fontWeight: 400,
            position:'absolute',
            top:'50%',
            left:'50%',
            transform:'translate(-60% ,-100%)',
            borderRadius:'30px',
        }

        download_link.style.transform

        for (const [key, value] of Object.entries(buttonStyles)){
            download_link.style[key] = value;
        }




        const blob = new Blob([summery_string]);
        const link = URL.createObjectURL(blob);
        download_link.href = link;
        download_link.textContent = "download Weights and Bias =>";
        download_link.download = "weightAndBias.text"
        root.appendChild(download_link)
    }

    save(root){

        const summeryOfmodel = [];
        const layerShapes = [];
        let NumberOfLayers = 0;
        this.layers.forEach(layer=>{
            if(layer.weights){
                const temporyContainer = [layer.weights , layer.bias]
                layerShapes.push([[layer.nInputs , layer.nNeurons]])
                NumberOfLayers++;
                summeryOfmodel.push(temporyContainer);
            }
        })

        this.#createDownloadButton(root,NumberOfLayers , layerShapes , summeryOfmodel);
        return summeryOfmodel;
    };


    #createLayerFromText(shape , weigths, bias){
        const layer = this.Layer_DenseLayer(shape[0],shape[1]);
        layer.weights = weigths;
        layer.bias = bias;
        this.addLayer(layer);
    }

    createFormModelSummary(pathToWeightTxtFile){
        const path = pathToWeightTxtFile;
        const xml = new XMLHttpRequest();
        xml.open('get' , path , false);
        xml.send();

        const arrayFromText = JSON.parse(xml.responseText);
        const numOfLayers = arrayFromText.splice(0,1)[0];
        const shapes = Matrix.reshape([numOfLayers , 2 ],arrayFromText.splice(0, 2*numOfLayers));
        let layerWeigthsAndBias = shapes.map(shape=>{
            const length = shape[0]* shape[1] + shape[1];
            return arrayFromText.splice(0 , length);
        })

        layerWeigthsAndBias = layerWeigthsAndBias.map((weigthAndBias ,index)=>{
            const nInputs = shapes[index][0]
            const nNeurons = shapes[index][1]
            const length = nInputs * nNeurons;
            const weigths = Matrix.reshape([nInputs , nNeurons],weigthAndBias.splice(0, length))
            const bias = matrix.reshape([1, nNeurons] , weigthAndBias.splice(0 , nNeurons));
            return [weigths , bias];
        })

        layerWeigthsAndBias.forEach((weigthAndBias , index)=>{
            this.#createLayerFromText(shapes[index] , weigthAndBias[0] , weigthAndBias[1]);

        })
    }


}


